// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Enables the provisioning and management of Redpanda clusters on AWS and GCP. A cluster must always have a network and resource group.
 *
 * ## Usage
 *
 * ### On AWS
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as redpanda from "@pulumiverse/redpanda";
 *
 * const testResourceGroup = new redpanda.ResourceGroup("testResourceGroup", {});
 * const config = new pulumi.Config();
 * const region = config.get("region") || "us-east-2";
 * const cloudProvider = config.get("cloudProvider") || "aws";
 * const testNetwork = new redpanda.Network("testNetwork", {
 *     resourceGroupId: testResourceGroup.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "dedicated",
 *     cidrBlock: "10.0.0.0/20",
 * });
 * const zones = config.getObject<any>("zones") || [
 *     "use2-az1",
 *     "use2-az2",
 *     "use2-az3",
 * ];
 * const throughputTier = config.get("throughputTier") || "tier-1-aws-v2-arm";
 * const testCluster = new redpanda.Cluster("testCluster", {
 *     resourceGroupId: testResourceGroup.id,
 *     networkId: testNetwork.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "dedicated",
 *     connectionType: "public",
 *     throughputTier: throughputTier,
 *     zones: zones,
 *     allowDeletion: true,
 *     tags: {
 *         key: "value",
 *     },
 * });
 * // aws_private_link = {
 * //   enabled         = true
 * //   connect_console = true
 * //   allowed_principals = ["arn:aws:iam::123456789024:root"]
 * // }
 * const resourceGroupName = config.get("resourceGroupName") || "testname";
 * const networkName = config.get("networkName") || "testname";
 * const clusterName = config.get("clusterName") || "testname";
 * const userPw = config.get("userPw") || "password";
 * const mechanism = config.get("mechanism") || "scram-sha-256";
 * const testUser = new redpanda.User("testUser", {
 *     password: userPw,
 *     mechanism: mechanism,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const partitionCount = config.getNumber("partitionCount") || 3;
 * const replicationFactor = config.getNumber("replicationFactor") || 3;
 * const testTopic = new redpanda.Topic("testTopic", {
 *     partitionCount: partitionCount,
 *     replicationFactor: replicationFactor,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 *     allowDeletion: true,
 * });
 * const testAcl = new redpanda.Acl("testAcl", {
 *     resourceType: "TOPIC",
 *     resourceName: testTopic.name,
 *     resourcePatternType: "LITERAL",
 *     principal: pulumi.interpolate`User:${testUser.name}`,
 *     host: "*",
 *     operation: "READ",
 *     permissionType: "ALLOW",
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const userName = config.get("userName") || "test-username";
 * const topicName = config.get("topicName") || "test-topic";
 * ```
 *
 * ### On GCP
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as redpanda from "@pulumiverse/redpanda";
 *
 * const testResourceGroup = new redpanda.ResourceGroup("testResourceGroup", {});
 * const config = new pulumi.Config();
 * const region = config.get("region") || "us-central1";
 * const cloudProvider = config.get("cloudProvider") || "gcp";
 * const testNetwork = new redpanda.Network("testNetwork", {
 *     resourceGroupId: testResourceGroup.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "dedicated",
 *     cidrBlock: "10.0.0.0/20",
 * });
 * const zones = config.getObject<any>("zones") || [
 *     "us-central1-a",
 *     "us-central1-b",
 *     "us-central1-c",
 * ];
 * const throughputTier = config.get("throughputTier") || "tier-1-gcp-um4g";
 * const testCluster = new redpanda.Cluster("testCluster", {
 *     resourceGroupId: testResourceGroup.id,
 *     networkId: testNetwork.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "dedicated",
 *     connectionType: "public",
 *     throughputTier: throughputTier,
 *     zones: zones,
 *     allowDeletion: true,
 * });
 * //# This is a reference for GCP tags
 * //   tags = {
 * //     "key" = "value"
 * //   }
 * //# This is a reference for GCP Private Service Connect
 * //   gcp_private_service_connect = {
 * //     enabled               = true
 * //     global_access_enabled = true
 * //     consumer_accept_list = [
 * //       {
 * //         source = "projects/123456789012"
 * //       }
 * //     ]
 * //   }
 * const clusterName = config.get("clusterName") || "";
 * const resourceGroupName = config.get("resourceGroupName") || "";
 * const networkName = config.get("networkName") || "";
 * const userPw = config.get("userPw") || "password";
 * const mechanism = config.get("mechanism") || "scram-sha-256";
 * const testUser = new redpanda.User("testUser", {
 *     password: userPw,
 *     mechanism: mechanism,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const partitionCount = config.getNumber("partitionCount") || 3;
 * const replicationFactor = config.getNumber("replicationFactor") || 3;
 * const testTopic = new redpanda.Topic("testTopic", {
 *     partitionCount: partitionCount,
 *     replicationFactor: replicationFactor,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 *     allowDeletion: true,
 * });
 * const testAcl = new redpanda.Acl("testAcl", {
 *     resourceType: "TOPIC",
 *     resourceName: testTopic.name,
 *     resourcePatternType: "LITERAL",
 *     principal: pulumi.interpolate`User:${testUser.name}`,
 *     host: "*",
 *     operation: "READ",
 *     permissionType: "ALLOW",
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const userName = config.get("userName") || "test-username";
 * const topicName = config.get("topicName") || "test-topic";
 * ```
 *
 * ### On Azure
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as redpanda from "@pulumiverse/redpanda";
 *
 * const testResourceGroup = new redpanda.ResourceGroup("testResourceGroup", {});
 * const config = new pulumi.Config();
 * const cloudProvider = config.get("cloudProvider") || "azure";
 * const region = config.get("region") || "eastus";
 * const testNetwork = new redpanda.Network("testNetwork", {
 *     resourceGroupId: testResourceGroup.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "dedicated",
 *     cidrBlock: "10.0.0.0/20",
 * });
 * const zones = config.getObject<any>("zones") || [
 *     "eastus-az1",
 *     "eastus-az2",
 *     "eastus-az3",
 * ];
 * const throughputTier = config.get("throughputTier") || "tier-1-azure-v3-x86";
 * const testCluster = new redpanda.Cluster("testCluster", {
 *     resourceGroupId: testResourceGroup.id,
 *     networkId: testNetwork.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "dedicated",
 *     connectionType: "public",
 *     throughputTier: throughputTier,
 *     zones: zones,
 *     allowDeletion: true,
 *     tags: {
 *         key: "value",
 *     },
 * });
 * //   azure_private_link = {
 * //     enabled         = true
 * //     connect_console = true
 * //     allowed_subscriptions = ["12345678-1234-1234-1234-123456789012"]
 * //   }
 * const resourceGroupName = config.get("resourceGroupName") || "testname";
 * const networkName = config.get("networkName") || "testname";
 * const clusterName = config.get("clusterName") || "testname";
 * const userPw = config.get("userPw") || "password";
 * const mechanism = config.get("mechanism") || "scram-sha-256";
 * const testUser = new redpanda.User("testUser", {
 *     password: userPw,
 *     mechanism: mechanism,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const partitionCount = config.getNumber("partitionCount") || 3;
 * const replicationFactor = config.getNumber("replicationFactor") || 3;
 * const testTopic = new redpanda.Topic("testTopic", {
 *     partitionCount: partitionCount,
 *     replicationFactor: replicationFactor,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 *     allowDeletion: true,
 * });
 * const testAcl = new redpanda.Acl("testAcl", {
 *     resourceType: "TOPIC",
 *     resourceName: testTopic.name,
 *     resourcePatternType: "LITERAL",
 *     principal: pulumi.interpolate`User:${testUser.name}`,
 *     host: "*",
 *     operation: "READ",
 *     permissionType: "ALLOW",
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const userName = config.get("userName") || "test-username";
 * const topicName = config.get("topicName") || "test-topic";
 * ```
 *
 * ## BYOC
 *
 * This configuration of cluster allows the end user to provide access to their cloud account to the provider so that it can create the necessary infrastructure in their account rather than in Redpanda's Cloud.
 *
 * #### Additional Requirements
 *
 * To build a BYOC cluster you must provide credentials that enable the provider to authenticate to the relevant cloud provider. How this works will depend on which cloud provider you are using.
 *
 * ### AWS BYOC
 *
 * To create a BYOC AWS cluster you must provide an AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies/) to create the necessary infrastructure.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as redpanda from "@pulumiverse/redpanda";
 *
 * const testResourceGroup = new redpanda.ResourceGroup("testResourceGroup", {});
 * const config = new pulumi.Config();
 * const region = config.get("region") || "us-east-2";
 * const cloudProvider = config.get("cloudProvider") || "aws";
 * const testNetwork = new redpanda.Network("testNetwork", {
 *     resourceGroupId: testResourceGroup.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "byoc",
 *     cidrBlock: "10.0.0.0/20",
 * });
 * const zones = config.getObject<any>("zones") || [
 *     "use2-az1",
 *     "use2-az2",
 *     "use2-az3",
 * ];
 * const throughputTier = config.get("throughputTier") || "tier-1-aws-v2-x86";
 * const testCluster = new redpanda.Cluster("testCluster", {
 *     resourceGroupId: testResourceGroup.id,
 *     networkId: testNetwork.id,
 *     cloudProvider: testNetwork.cloudProvider,
 *     region: testNetwork.region,
 *     clusterType: testNetwork.clusterType,
 *     connectionType: "public",
 *     throughputTier: throughputTier,
 *     zones: zones,
 *     allowDeletion: true,
 *     tags: {
 *         key: "value",
 *     },
 * });
 * // aws_private_link = {
 * //   enabled         = true
 * //   connect_console = true
 * //   allowed_principals = ["arn:aws:iam::123456789024:root"]
 * // }
 * const resourceGroupName = config.get("resourceGroupName") || "testname";
 * const networkName = config.get("networkName") || "testname";
 * const clusterName = config.get("clusterName") || "testname";
 * const userPw = config.get("userPw") || "password";
 * const mechanism = config.get("mechanism") || "scram-sha-256";
 * const testUser = new redpanda.User("testUser", {
 *     password: userPw,
 *     mechanism: mechanism,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const partitionCount = config.getNumber("partitionCount") || 3;
 * const replicationFactor = config.getNumber("replicationFactor") || 3;
 * const testTopic = new redpanda.Topic("testTopic", {
 *     partitionCount: partitionCount,
 *     replicationFactor: replicationFactor,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 *     allowDeletion: true,
 * });
 * const testAcl = new redpanda.Acl("testAcl", {
 *     resourceType: "TOPIC",
 *     resourceName: testTopic.name,
 *     resourcePatternType: "LITERAL",
 *     principal: pulumi.interpolate`User:${testUser.name}`,
 *     host: "*",
 *     operation: "READ",
 *     permissionType: "ALLOW",
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const userName = config.get("userName") || "test-username";
 * const topicName = config.get("topicName") || "test-topic";
 * ```
 *
 * ### GCP BYOC
 *
 * To create a GCP BYOC cluster you must provide a GCP_PROJECT_ID and GOOGLE_CREDENTIALS. We also accept the credentials encoded in base64 format if you use GOOGLE_CREDENTIALS_BASE64. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-gcp/) to create the necessary infrastructure.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as redpanda from "@pulumiverse/redpanda";
 *
 * const testResourceGroup = new redpanda.ResourceGroup("testResourceGroup", {});
 * const config = new pulumi.Config();
 * const region = config.get("region") || "us-central1";
 * const cloudProvider = config.get("cloudProvider") || "gcp";
 * const testNetwork = new redpanda.Network("testNetwork", {
 *     resourceGroupId: testResourceGroup.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "byoc",
 *     cidrBlock: "10.0.0.0/20",
 * });
 * const zones = config.getObject<any>("zones") || [
 *     "us-central1-a",
 *     "us-central1-b",
 *     "us-central1-c",
 * ];
 * const throughputTier = config.get("throughputTier") || "tier-1-gcp-um4g";
 * const testCluster = new redpanda.Cluster("testCluster", {
 *     resourceGroupId: testResourceGroup.id,
 *     networkId: testNetwork.id,
 *     cloudProvider: testNetwork.cloudProvider,
 *     region: testNetwork.region,
 *     clusterType: testNetwork.clusterType,
 *     connectionType: "public",
 *     throughputTier: throughputTier,
 *     zones: zones,
 *     allowDeletion: true,
 * });
 * //# This is a reference for GCP tags
 * //   tags = {
 * //     "key" = "value"
 * //   }
 * //# This is a reference for GCP Private Service Connect
 * //   gcp_private_service_connect = {
 * //     enabled               = true
 * //     global_access_enabled = true
 * //     consumer_accept_list = [
 * //       {
 * //         source = "projects/123456789012"
 * //       }
 * //     ]
 * //   }
 * const clusterName = config.get("clusterName") || "";
 * const resourceGroupName = config.get("resourceGroupName") || "";
 * const networkName = config.get("networkName") || "";
 * const userPw = config.get("userPw") || "password";
 * const mechanism = config.get("mechanism") || "scram-sha-256";
 * const testUser = new redpanda.User("testUser", {
 *     password: userPw,
 *     mechanism: mechanism,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const partitionCount = config.getNumber("partitionCount") || 3;
 * const replicationFactor = config.getNumber("replicationFactor") || 3;
 * const testTopic = new redpanda.Topic("testTopic", {
 *     partitionCount: partitionCount,
 *     replicationFactor: replicationFactor,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 *     allowDeletion: true,
 * });
 * const testAcl = new redpanda.Acl("testAcl", {
 *     resourceType: "TOPIC",
 *     resourceName: testTopic.name,
 *     resourcePatternType: "LITERAL",
 *     principal: pulumi.interpolate`User:${testUser.name}`,
 *     host: "*",
 *     operation: "READ",
 *     permissionType: "ALLOW",
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const userName = config.get("userName") || "test-username";
 * const topicName = config.get("topicName") || "test-topic";
 * ```
 *
 * ### Azure BYOC
 *
 * To create a BYOC Azure cluster you must provide Azure credentials, be logged in to the Azure CLI, or specify an Azure authentication method. This provider supports the same authentication methods and environment variables as the official AzureRM provider. For example, to use a service principal and client certificate, you can pass the environment variables `ARM_CLIENT_ID`, `ARM_CLIENT_SECRET`, `ARM_TENANT_ID`, and `ARM_SUBSCRIPTION_ID`.
 *
 * The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-azure/) to create the necessary infrastructure.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as redpanda from "@pulumiverse/redpanda";
 *
 * const testResourceGroup = new redpanda.ResourceGroup("testResourceGroup", {});
 * const config = new pulumi.Config();
 * const cloudProvider = config.get("cloudProvider") || "azure";
 * const region = config.get("region") || "eastus";
 * const testNetwork = new redpanda.Network("testNetwork", {
 *     resourceGroupId: testResourceGroup.id,
 *     cloudProvider: cloudProvider,
 *     region: region,
 *     clusterType: "byoc",
 *     cidrBlock: "10.0.0.0/20",
 * });
 * const zones = config.getObject<any>("zones") || [
 *     "eastus-az1",
 *     "eastus-az2",
 *     "eastus-az3",
 * ];
 * const throughputTier = config.get("throughputTier") || "tier-1-azure-v3-x86";
 * const testCluster = new redpanda.Cluster("testCluster", {
 *     resourceGroupId: testResourceGroup.id,
 *     networkId: testNetwork.id,
 *     cloudProvider: testNetwork.cloudProvider,
 *     region: testNetwork.region,
 *     clusterType: testNetwork.clusterType,
 *     connectionType: "public",
 *     throughputTier: throughputTier,
 *     zones: zones,
 *     allowDeletion: true,
 *     tags: {
 *         key: "value",
 *     },
 * });
 * // azure_private_link = {
 * //   enabled         = true
 * //   connect_console = true
 * //   allowed_subscriptions = ["12345678-1234-1234-1234-123456789012"]
 * // }
 * const resourceGroupName = config.get("resourceGroupName") || "testname";
 * const networkName = config.get("networkName") || "testname";
 * const clusterName = config.get("clusterName") || "testname";
 * const userPw = config.get("userPw") || "password";
 * const mechanism = config.get("mechanism") || "scram-sha-256";
 * const testUser = new redpanda.User("testUser", {
 *     password: userPw,
 *     mechanism: mechanism,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const partitionCount = config.getNumber("partitionCount") || 3;
 * const replicationFactor = config.getNumber("replicationFactor") || 3;
 * const testTopic = new redpanda.Topic("testTopic", {
 *     partitionCount: partitionCount,
 *     replicationFactor: replicationFactor,
 *     clusterApiUrl: testCluster.clusterApiUrl,
 *     allowDeletion: true,
 * });
 * const testAcl = new redpanda.Acl("testAcl", {
 *     resourceType: "TOPIC",
 *     resourceName: testTopic.name,
 *     resourcePatternType: "LITERAL",
 *     principal: pulumi.interpolate`User:${testUser.name}`,
 *     host: "*",
 *     operation: "READ",
 *     permissionType: "ALLOW",
 *     clusterApiUrl: testCluster.clusterApiUrl,
 * });
 * const userName = config.get("userName") || "test-username";
 * const topicName = config.get("topicName") || "test-topic";
 * ```
 *
 * ## BYOVPC
 *
 * This accepts a network and other elements created by the end user inside their cloud provider account (currently limited to AWS) and builds a Redpanda Cluster inside it.
 *
 * There is a module provided for convenience of the end user here that handles the necessary setup. It contains outputs for the inputs the provider requires.
 *
 * ### Example Usage of a data source BYOC to manage users and ACLs
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as redpanda from "@pulumiverse/redpanda";
 *
 * const config = new pulumi.Config();
 * const clusterId = config.get("clusterId") || "";
 * const testCluster = redpanda.getCluster({
 *     id: clusterId,
 * });
 * const topicConfig = config.getObject<any>("topicConfig") || {
 *     "cleanup.policy": "compact",
 *     "flush.ms": 100,
 *     "compression.type": "snappy",
 * };
 * const partitionCount = config.getNumber("partitionCount") || 3;
 * const replicationFactor = config.getNumber("replicationFactor") || 3;
 * const testTopic = new redpanda.Topic("testTopic", {
 *     partitionCount: partitionCount,
 *     replicationFactor: replicationFactor,
 *     clusterApiUrl: testCluster.then(testCluster => testCluster.clusterApiUrl),
 *     allowDeletion: true,
 *     configuration: topicConfig,
 * });
 * const userPw = config.get("userPw") || "password";
 * const mechanism = config.get("mechanism") || "scram-sha-256";
 * const testUser = new redpanda.User("testUser", {
 *     password: userPw,
 *     mechanism: mechanism,
 *     clusterApiUrl: testCluster.then(testCluster => testCluster.clusterApiUrl),
 * });
 * const testAcl = new redpanda.Acl("testAcl", {
 *     resourceType: "CLUSTER",
 *     resourceName: "kafka-cluster",
 *     resourcePatternType: "LITERAL",
 *     principal: pulumi.interpolate`User:${testUser.name}`,
 *     host: "*",
 *     operation: "ALTER",
 *     permissionType: "ALLOW",
 *     clusterApiUrl: testCluster.then(testCluster => testCluster.clusterApiUrl),
 * });
 * const userName = config.get("userName") || "data-test-username";
 * const topicName = config.get("topicName") || "data-test-topic";
 * ```
 *
 * ## Import
 *
 * ```sh
 * $ pulumi import redpanda:index/cluster:Cluster example clusterId
 * ```
 */
export class Cluster extends pulumi.CustomResource {
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClusterState, opts?: pulumi.CustomResourceOptions): Cluster {
        return new Cluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'redpanda:index/cluster:Cluster';

    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Cluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }

    /**
     * Allows deletion of the cluster. Defaults to false.
     */
    public readonly allowDeletion!: pulumi.Output<boolean | undefined>;
    /**
     * AWS PrivateLink configuration.
     */
    public readonly awsPrivateLink!: pulumi.Output<outputs.ClusterAwsPrivateLink | undefined>;
    /**
     * Azure Private Link configuration.
     */
    public readonly azurePrivateLink!: pulumi.Output<outputs.ClusterAzurePrivateLink | undefined>;
    /**
     * Cloud provider where resources are created.
     */
    public readonly cloudProvider!: pulumi.Output<string | undefined>;
    /**
     * The URL of the cluster API.
     */
    public /*out*/ readonly clusterApiUrl!: pulumi.Output<string>;
    /**
     * Cluster type. Type is immutable and can only be set on cluster creation.
     */
    public readonly clusterType!: pulumi.Output<string>;
    /**
     * Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
     */
    public readonly connectionType!: pulumi.Output<string>;
    /**
     * Timestamp when the cluster was created.
     */
    public /*out*/ readonly createdAt!: pulumi.Output<string>;
    /**
     * Customer managed resources configuration for the cluster.
     */
    public readonly customerManagedResources!: pulumi.Output<outputs.ClusterCustomerManagedResources | undefined>;
    /**
     * If true, GCP global access is enabled.
     */
    public readonly gcpGlobalAccessEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * GCP Private Service Connect configuration.
     */
    public readonly gcpPrivateServiceConnect!: pulumi.Output<outputs.ClusterGcpPrivateServiceConnect | undefined>;
    /**
     * HTTP Proxy properties.
     */
    public readonly httpProxy!: pulumi.Output<outputs.ClusterHttpProxy>;
    /**
     * Cluster's Kafka API properties.
     */
    public readonly kafkaApi!: pulumi.Output<outputs.ClusterKafkaApi>;
    /**
     * Kafka Connect configuration.
     */
    public readonly kafkaConnect!: pulumi.Output<outputs.ClusterKafkaConnect>;
    /**
     * Maintenance window configuration for the cluster.
     */
    public readonly maintenanceWindowConfig!: pulumi.Output<outputs.ClusterMaintenanceWindowConfig>;
    /**
     * Unique name of the cluster.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Network ID where cluster is placed.
     */
    public readonly networkId!: pulumi.Output<string>;
    /**
     * Prometheus metrics endpoint properties.
     */
    public /*out*/ readonly prometheus!: pulumi.Output<outputs.ClusterPrometheus>;
    /**
     * IDs of clusters that can create read-only topics from this cluster.
     */
    public readonly readReplicaClusterIds!: pulumi.Output<string[] | undefined>;
    /**
     * Redpanda Console properties.
     */
    public /*out*/ readonly redpandaConsole!: pulumi.Output<outputs.ClusterRedpandaConsole>;
    /**
     * Current Redpanda version of the cluster.
     */
    public readonly redpandaVersion!: pulumi.Output<string | undefined>;
    /**
     * Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
     */
    public readonly region!: pulumi.Output<string | undefined>;
    /**
     * Resource group ID of the cluster.
     */
    public readonly resourceGroupId!: pulumi.Output<string>;
    /**
     * Schema Registry properties.
     */
    public readonly schemaRegistry!: pulumi.Output<outputs.ClusterSchemaRegistry>;
    /**
     * Current state of the cluster.
     */
    public /*out*/ readonly state!: pulumi.Output<string>;
    /**
     * Detailed state description when cluster is in a non-ready state.
     */
    public /*out*/ readonly stateDescription!: pulumi.Output<outputs.ClusterStateDescription>;
    /**
     * Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
     */
    public readonly tags!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Throughput tier of the cluster.
     */
    public readonly throughputTier!: pulumi.Output<string>;
    /**
     * Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
     */
    public readonly zones!: pulumi.Output<string[] | undefined>;

    /**
     * Create a Cluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClusterArgs | ClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClusterState | undefined;
            resourceInputs["allowDeletion"] = state ? state.allowDeletion : undefined;
            resourceInputs["awsPrivateLink"] = state ? state.awsPrivateLink : undefined;
            resourceInputs["azurePrivateLink"] = state ? state.azurePrivateLink : undefined;
            resourceInputs["cloudProvider"] = state ? state.cloudProvider : undefined;
            resourceInputs["clusterApiUrl"] = state ? state.clusterApiUrl : undefined;
            resourceInputs["clusterType"] = state ? state.clusterType : undefined;
            resourceInputs["connectionType"] = state ? state.connectionType : undefined;
            resourceInputs["createdAt"] = state ? state.createdAt : undefined;
            resourceInputs["customerManagedResources"] = state ? state.customerManagedResources : undefined;
            resourceInputs["gcpGlobalAccessEnabled"] = state ? state.gcpGlobalAccessEnabled : undefined;
            resourceInputs["gcpPrivateServiceConnect"] = state ? state.gcpPrivateServiceConnect : undefined;
            resourceInputs["httpProxy"] = state ? state.httpProxy : undefined;
            resourceInputs["kafkaApi"] = state ? state.kafkaApi : undefined;
            resourceInputs["kafkaConnect"] = state ? state.kafkaConnect : undefined;
            resourceInputs["maintenanceWindowConfig"] = state ? state.maintenanceWindowConfig : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["networkId"] = state ? state.networkId : undefined;
            resourceInputs["prometheus"] = state ? state.prometheus : undefined;
            resourceInputs["readReplicaClusterIds"] = state ? state.readReplicaClusterIds : undefined;
            resourceInputs["redpandaConsole"] = state ? state.redpandaConsole : undefined;
            resourceInputs["redpandaVersion"] = state ? state.redpandaVersion : undefined;
            resourceInputs["region"] = state ? state.region : undefined;
            resourceInputs["resourceGroupId"] = state ? state.resourceGroupId : undefined;
            resourceInputs["schemaRegistry"] = state ? state.schemaRegistry : undefined;
            resourceInputs["state"] = state ? state.state : undefined;
            resourceInputs["stateDescription"] = state ? state.stateDescription : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["throughputTier"] = state ? state.throughputTier : undefined;
            resourceInputs["zones"] = state ? state.zones : undefined;
        } else {
            const args = argsOrState as ClusterArgs | undefined;
            if ((!args || args.clusterType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'clusterType'");
            }
            if ((!args || args.connectionType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'connectionType'");
            }
            if ((!args || args.networkId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'networkId'");
            }
            if ((!args || args.resourceGroupId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupId'");
            }
            if ((!args || args.throughputTier === undefined) && !opts.urn) {
                throw new Error("Missing required property 'throughputTier'");
            }
            resourceInputs["allowDeletion"] = args ? args.allowDeletion : undefined;
            resourceInputs["awsPrivateLink"] = args ? args.awsPrivateLink : undefined;
            resourceInputs["azurePrivateLink"] = args ? args.azurePrivateLink : undefined;
            resourceInputs["cloudProvider"] = args ? args.cloudProvider : undefined;
            resourceInputs["clusterType"] = args ? args.clusterType : undefined;
            resourceInputs["connectionType"] = args ? args.connectionType : undefined;
            resourceInputs["customerManagedResources"] = args ? args.customerManagedResources : undefined;
            resourceInputs["gcpGlobalAccessEnabled"] = args ? args.gcpGlobalAccessEnabled : undefined;
            resourceInputs["gcpPrivateServiceConnect"] = args ? args.gcpPrivateServiceConnect : undefined;
            resourceInputs["httpProxy"] = args ? args.httpProxy : undefined;
            resourceInputs["kafkaApi"] = args ? args.kafkaApi : undefined;
            resourceInputs["kafkaConnect"] = args ? args.kafkaConnect : undefined;
            resourceInputs["maintenanceWindowConfig"] = args ? args.maintenanceWindowConfig : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["networkId"] = args ? args.networkId : undefined;
            resourceInputs["readReplicaClusterIds"] = args ? args.readReplicaClusterIds : undefined;
            resourceInputs["redpandaVersion"] = args ? args.redpandaVersion : undefined;
            resourceInputs["region"] = args ? args.region : undefined;
            resourceInputs["resourceGroupId"] = args ? args.resourceGroupId : undefined;
            resourceInputs["schemaRegistry"] = args ? args.schemaRegistry : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["throughputTier"] = args ? args.throughputTier : undefined;
            resourceInputs["zones"] = args ? args.zones : undefined;
            resourceInputs["clusterApiUrl"] = undefined /*out*/;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["prometheus"] = undefined /*out*/;
            resourceInputs["redpandaConsole"] = undefined /*out*/;
            resourceInputs["state"] = undefined /*out*/;
            resourceInputs["stateDescription"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Cluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
    /**
     * Allows deletion of the cluster. Defaults to false.
     */
    allowDeletion?: pulumi.Input<boolean>;
    /**
     * AWS PrivateLink configuration.
     */
    awsPrivateLink?: pulumi.Input<inputs.ClusterAwsPrivateLink>;
    /**
     * Azure Private Link configuration.
     */
    azurePrivateLink?: pulumi.Input<inputs.ClusterAzurePrivateLink>;
    /**
     * Cloud provider where resources are created.
     */
    cloudProvider?: pulumi.Input<string>;
    /**
     * The URL of the cluster API.
     */
    clusterApiUrl?: pulumi.Input<string>;
    /**
     * Cluster type. Type is immutable and can only be set on cluster creation.
     */
    clusterType?: pulumi.Input<string>;
    /**
     * Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
     */
    connectionType?: pulumi.Input<string>;
    /**
     * Timestamp when the cluster was created.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * Customer managed resources configuration for the cluster.
     */
    customerManagedResources?: pulumi.Input<inputs.ClusterCustomerManagedResources>;
    /**
     * If true, GCP global access is enabled.
     */
    gcpGlobalAccessEnabled?: pulumi.Input<boolean>;
    /**
     * GCP Private Service Connect configuration.
     */
    gcpPrivateServiceConnect?: pulumi.Input<inputs.ClusterGcpPrivateServiceConnect>;
    /**
     * HTTP Proxy properties.
     */
    httpProxy?: pulumi.Input<inputs.ClusterHttpProxy>;
    /**
     * Cluster's Kafka API properties.
     */
    kafkaApi?: pulumi.Input<inputs.ClusterKafkaApi>;
    /**
     * Kafka Connect configuration.
     */
    kafkaConnect?: pulumi.Input<inputs.ClusterKafkaConnect>;
    /**
     * Maintenance window configuration for the cluster.
     */
    maintenanceWindowConfig?: pulumi.Input<inputs.ClusterMaintenanceWindowConfig>;
    /**
     * Unique name of the cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * Network ID where cluster is placed.
     */
    networkId?: pulumi.Input<string>;
    /**
     * Prometheus metrics endpoint properties.
     */
    prometheus?: pulumi.Input<inputs.ClusterPrometheus>;
    /**
     * IDs of clusters that can create read-only topics from this cluster.
     */
    readReplicaClusterIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Redpanda Console properties.
     */
    redpandaConsole?: pulumi.Input<inputs.ClusterRedpandaConsole>;
    /**
     * Current Redpanda version of the cluster.
     */
    redpandaVersion?: pulumi.Input<string>;
    /**
     * Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
     */
    region?: pulumi.Input<string>;
    /**
     * Resource group ID of the cluster.
     */
    resourceGroupId?: pulumi.Input<string>;
    /**
     * Schema Registry properties.
     */
    schemaRegistry?: pulumi.Input<inputs.ClusterSchemaRegistry>;
    /**
     * Current state of the cluster.
     */
    state?: pulumi.Input<string>;
    /**
     * Detailed state description when cluster is in a non-ready state.
     */
    stateDescription?: pulumi.Input<inputs.ClusterStateDescription>;
    /**
     * Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Throughput tier of the cluster.
     */
    throughputTier?: pulumi.Input<string>;
    /**
     * Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
     */
    zones?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
    /**
     * Allows deletion of the cluster. Defaults to false.
     */
    allowDeletion?: pulumi.Input<boolean>;
    /**
     * AWS PrivateLink configuration.
     */
    awsPrivateLink?: pulumi.Input<inputs.ClusterAwsPrivateLink>;
    /**
     * Azure Private Link configuration.
     */
    azurePrivateLink?: pulumi.Input<inputs.ClusterAzurePrivateLink>;
    /**
     * Cloud provider where resources are created.
     */
    cloudProvider?: pulumi.Input<string>;
    /**
     * Cluster type. Type is immutable and can only be set on cluster creation.
     */
    clusterType: pulumi.Input<string>;
    /**
     * Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
     */
    connectionType: pulumi.Input<string>;
    /**
     * Customer managed resources configuration for the cluster.
     */
    customerManagedResources?: pulumi.Input<inputs.ClusterCustomerManagedResources>;
    /**
     * If true, GCP global access is enabled.
     */
    gcpGlobalAccessEnabled?: pulumi.Input<boolean>;
    /**
     * GCP Private Service Connect configuration.
     */
    gcpPrivateServiceConnect?: pulumi.Input<inputs.ClusterGcpPrivateServiceConnect>;
    /**
     * HTTP Proxy properties.
     */
    httpProxy?: pulumi.Input<inputs.ClusterHttpProxy>;
    /**
     * Cluster's Kafka API properties.
     */
    kafkaApi?: pulumi.Input<inputs.ClusterKafkaApi>;
    /**
     * Kafka Connect configuration.
     */
    kafkaConnect?: pulumi.Input<inputs.ClusterKafkaConnect>;
    /**
     * Maintenance window configuration for the cluster.
     */
    maintenanceWindowConfig?: pulumi.Input<inputs.ClusterMaintenanceWindowConfig>;
    /**
     * Unique name of the cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * Network ID where cluster is placed.
     */
    networkId: pulumi.Input<string>;
    /**
     * IDs of clusters that can create read-only topics from this cluster.
     */
    readReplicaClusterIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Current Redpanda version of the cluster.
     */
    redpandaVersion?: pulumi.Input<string>;
    /**
     * Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
     */
    region?: pulumi.Input<string>;
    /**
     * Resource group ID of the cluster.
     */
    resourceGroupId: pulumi.Input<string>;
    /**
     * Schema Registry properties.
     */
    schemaRegistry?: pulumi.Input<inputs.ClusterSchemaRegistry>;
    /**
     * Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Throughput tier of the cluster.
     */
    throughputTier: pulumi.Input<string>;
    /**
     * Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
     */
    zones?: pulumi.Input<pulumi.Input<string>[]>;
}
