// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package redpanda

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda/internal"
)

// Enables the provisioning and management of Redpanda clusters on AWS and GCP. A cluster must always have a network and resource group.
//
// ## Usage
//
// ### On AWS
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := redpanda.NewResourceGroup(ctx, "testResourceGroup", nil)
//			if err != nil {
//				return err
//			}
//			cfg := config.New(ctx, "")
//			region := "us-east-2"
//			if param := cfg.Get("region"); param != "" {
//				region = param
//			}
//			cloudProvider := "aws"
//			if param := cfg.Get("cloudProvider"); param != "" {
//				cloudProvider = param
//			}
//			testNetwork, err := redpanda.NewNetwork(ctx, "testNetwork", &redpanda.NetworkArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				CidrBlock:       pulumi.String("10.0.0.0/20"),
//			})
//			if err != nil {
//				return err
//			}
//			zones := []string{
//				"use2-az1",
//				"use2-az2",
//				"use2-az3",
//			}
//			if param := cfg.GetObject("zones"); param != nil {
//				zones = param
//			}
//			throughputTier := "tier-1-aws-v2-arm"
//			if param := cfg.Get("throughputTier"); param != "" {
//				throughputTier = param
//			}
//			testCluster, err := redpanda.NewCluster(ctx, "testCluster", &redpanda.ClusterArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				NetworkId:       testNetwork.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				ConnectionType:  pulumi.String("public"),
//				ThroughputTier:  pulumi.String(throughputTier),
//				Zones:           pulumi.Any(zones),
//				AllowDeletion:   pulumi.Bool(true),
//				Tags: pulumi.StringMap{
//					"key": pulumi.String("value"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			resourceGroupName := "testname"
//			if param := cfg.Get("resourceGroupName"); param != "" {
//				resourceGroupName = param
//			}
//			networkName := "testname"
//			if param := cfg.Get("networkName"); param != "" {
//				networkName = param
//			}
//			clusterName := "testname"
//			if param := cfg.Get("clusterName"); param != "" {
//				clusterName = param
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			testTopic, err := redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     testCluster.ClusterApiUrl,
//				AllowDeletion:     pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("TOPIC"),
//				ResourceName:        testTopic.Name,
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("READ"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			userName := "test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### On GCP
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := redpanda.NewResourceGroup(ctx, "testResourceGroup", nil)
//			if err != nil {
//				return err
//			}
//			cfg := config.New(ctx, "")
//			region := "us-central1"
//			if param := cfg.Get("region"); param != "" {
//				region = param
//			}
//			cloudProvider := "gcp"
//			if param := cfg.Get("cloudProvider"); param != "" {
//				cloudProvider = param
//			}
//			testNetwork, err := redpanda.NewNetwork(ctx, "testNetwork", &redpanda.NetworkArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				CidrBlock:       pulumi.String("10.0.0.0/20"),
//			})
//			if err != nil {
//				return err
//			}
//			zones := []string{
//				"us-central1-a",
//				"us-central1-b",
//				"us-central1-c",
//			}
//			if param := cfg.GetObject("zones"); param != nil {
//				zones = param
//			}
//			throughputTier := "tier-1-gcp-um4g"
//			if param := cfg.Get("throughputTier"); param != "" {
//				throughputTier = param
//			}
//			testCluster, err := redpanda.NewCluster(ctx, "testCluster", &redpanda.ClusterArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				NetworkId:       testNetwork.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				ConnectionType:  pulumi.String("public"),
//				ThroughputTier:  pulumi.String(throughputTier),
//				Zones:           pulumi.Any(zones),
//				AllowDeletion:   pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			clusterName := ""
//			if param := cfg.Get("clusterName"); param != "" {
//				clusterName = param
//			}
//			resourceGroupName := ""
//			if param := cfg.Get("resourceGroupName"); param != "" {
//				resourceGroupName = param
//			}
//			networkName := ""
//			if param := cfg.Get("networkName"); param != "" {
//				networkName = param
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			testTopic, err := redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     testCluster.ClusterApiUrl,
//				AllowDeletion:     pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("TOPIC"),
//				ResourceName:        testTopic.Name,
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("READ"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			userName := "test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### On Azure
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := redpanda.NewResourceGroup(ctx, "testResourceGroup", nil)
//			if err != nil {
//				return err
//			}
//			cfg := config.New(ctx, "")
//			cloudProvider := "azure"
//			if param := cfg.Get("cloudProvider"); param != "" {
//				cloudProvider = param
//			}
//			region := "eastus"
//			if param := cfg.Get("region"); param != "" {
//				region = param
//			}
//			testNetwork, err := redpanda.NewNetwork(ctx, "testNetwork", &redpanda.NetworkArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				CidrBlock:       pulumi.String("10.0.0.0/20"),
//			})
//			if err != nil {
//				return err
//			}
//			zones := []string{
//				"eastus-az1",
//				"eastus-az2",
//				"eastus-az3",
//			}
//			if param := cfg.GetObject("zones"); param != nil {
//				zones = param
//			}
//			throughputTier := "tier-1-azure-v3-x86"
//			if param := cfg.Get("throughputTier"); param != "" {
//				throughputTier = param
//			}
//			testCluster, err := redpanda.NewCluster(ctx, "testCluster", &redpanda.ClusterArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				NetworkId:       testNetwork.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				ConnectionType:  pulumi.String("public"),
//				ThroughputTier:  pulumi.String(throughputTier),
//				Zones:           pulumi.Any(zones),
//				AllowDeletion:   pulumi.Bool(true),
//				Tags: pulumi.StringMap{
//					"key": pulumi.String("value"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			resourceGroupName := "testname"
//			if param := cfg.Get("resourceGroupName"); param != "" {
//				resourceGroupName = param
//			}
//			networkName := "testname"
//			if param := cfg.Get("networkName"); param != "" {
//				networkName = param
//			}
//			clusterName := "testname"
//			if param := cfg.Get("clusterName"); param != "" {
//				clusterName = param
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			testTopic, err := redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     testCluster.ClusterApiUrl,
//				AllowDeletion:     pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("TOPIC"),
//				ResourceName:        testTopic.Name,
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("READ"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			userName := "test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## BYOC
//
// This configuration of cluster allows the end user to provide access to their cloud account to the provider so that it can create the necessary infrastructure in their account rather than in Redpanda's Cloud.
//
// #### Additional Requirements
//
// To build a BYOC cluster you must provide credentials that enable the provider to authenticate to the relevant cloud provider. How this works will depend on which cloud provider you are using.
//
// ### AWS BYOC
//
// To create a BYOC AWS cluster you must provide an AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies/) to create the necessary infrastructure.
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := redpanda.NewResourceGroup(ctx, "testResourceGroup", nil)
//			if err != nil {
//				return err
//			}
//			cfg := config.New(ctx, "")
//			region := "us-east-2"
//			if param := cfg.Get("region"); param != "" {
//				region = param
//			}
//			cloudProvider := "aws"
//			if param := cfg.Get("cloudProvider"); param != "" {
//				cloudProvider = param
//			}
//			testNetwork, err := redpanda.NewNetwork(ctx, "testNetwork", &redpanda.NetworkArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("byoc"),
//				CidrBlock:       pulumi.String("10.0.0.0/20"),
//			})
//			if err != nil {
//				return err
//			}
//			zones := []string{
//				"use2-az1",
//				"use2-az2",
//				"use2-az3",
//			}
//			if param := cfg.GetObject("zones"); param != nil {
//				zones = param
//			}
//			throughputTier := "tier-1-aws-v2-x86"
//			if param := cfg.Get("throughputTier"); param != "" {
//				throughputTier = param
//			}
//			testCluster, err := redpanda.NewCluster(ctx, "testCluster", &redpanda.ClusterArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				NetworkId:       testNetwork.ID(),
//				CloudProvider:   testNetwork.CloudProvider,
//				Region:          testNetwork.Region,
//				ClusterType:     testNetwork.ClusterType,
//				ConnectionType:  pulumi.String("public"),
//				ThroughputTier:  pulumi.String(throughputTier),
//				Zones:           pulumi.Any(zones),
//				AllowDeletion:   pulumi.Bool(true),
//				Tags: pulumi.StringMap{
//					"key": pulumi.String("value"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			resourceGroupName := "testname"
//			if param := cfg.Get("resourceGroupName"); param != "" {
//				resourceGroupName = param
//			}
//			networkName := "testname"
//			if param := cfg.Get("networkName"); param != "" {
//				networkName = param
//			}
//			clusterName := "testname"
//			if param := cfg.Get("clusterName"); param != "" {
//				clusterName = param
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			testTopic, err := redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     testCluster.ClusterApiUrl,
//				AllowDeletion:     pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("TOPIC"),
//				ResourceName:        testTopic.Name,
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("READ"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			userName := "test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### GCP BYOC
//
// To create a GCP BYOC cluster you must provide a GCP_PROJECT_ID and GOOGLE_CREDENTIALS. We also accept the credentials encoded in base64 format if you use GOOGLE_CREDENTIALS_BASE64. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-gcp/) to create the necessary infrastructure.
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := redpanda.NewResourceGroup(ctx, "testResourceGroup", nil)
//			if err != nil {
//				return err
//			}
//			cfg := config.New(ctx, "")
//			region := "us-central1"
//			if param := cfg.Get("region"); param != "" {
//				region = param
//			}
//			cloudProvider := "gcp"
//			if param := cfg.Get("cloudProvider"); param != "" {
//				cloudProvider = param
//			}
//			testNetwork, err := redpanda.NewNetwork(ctx, "testNetwork", &redpanda.NetworkArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("byoc"),
//				CidrBlock:       pulumi.String("10.0.0.0/20"),
//			})
//			if err != nil {
//				return err
//			}
//			zones := []string{
//				"us-central1-a",
//				"us-central1-b",
//				"us-central1-c",
//			}
//			if param := cfg.GetObject("zones"); param != nil {
//				zones = param
//			}
//			throughputTier := "tier-1-gcp-um4g"
//			if param := cfg.Get("throughputTier"); param != "" {
//				throughputTier = param
//			}
//			testCluster, err := redpanda.NewCluster(ctx, "testCluster", &redpanda.ClusterArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				NetworkId:       testNetwork.ID(),
//				CloudProvider:   testNetwork.CloudProvider,
//				Region:          testNetwork.Region,
//				ClusterType:     testNetwork.ClusterType,
//				ConnectionType:  pulumi.String("public"),
//				ThroughputTier:  pulumi.String(throughputTier),
//				Zones:           pulumi.Any(zones),
//				AllowDeletion:   pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			clusterName := ""
//			if param := cfg.Get("clusterName"); param != "" {
//				clusterName = param
//			}
//			resourceGroupName := ""
//			if param := cfg.Get("resourceGroupName"); param != "" {
//				resourceGroupName = param
//			}
//			networkName := ""
//			if param := cfg.Get("networkName"); param != "" {
//				networkName = param
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			testTopic, err := redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     testCluster.ClusterApiUrl,
//				AllowDeletion:     pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("TOPIC"),
//				ResourceName:        testTopic.Name,
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("READ"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			userName := "test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Azure BYOC
//
// To create a BYOC Azure cluster you must provide Azure credentials, be logged in to the Azure CLI, or specify an Azure authentication method. This provider supports the same authentication methods and environment variables as the official AzureRM provider. For example, to use a service principal and client certificate, you can pass the environment variables `ARM_CLIENT_ID`, `ARM_CLIENT_SECRET`, `ARM_TENANT_ID`, and `ARM_SUBSCRIPTION_ID`.
//
// The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-azure/) to create the necessary infrastructure.
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := redpanda.NewResourceGroup(ctx, "testResourceGroup", nil)
//			if err != nil {
//				return err
//			}
//			cfg := config.New(ctx, "")
//			cloudProvider := "azure"
//			if param := cfg.Get("cloudProvider"); param != "" {
//				cloudProvider = param
//			}
//			region := "eastus"
//			if param := cfg.Get("region"); param != "" {
//				region = param
//			}
//			testNetwork, err := redpanda.NewNetwork(ctx, "testNetwork", &redpanda.NetworkArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("byoc"),
//				CidrBlock:       pulumi.String("10.0.0.0/20"),
//			})
//			if err != nil {
//				return err
//			}
//			zones := []string{
//				"eastus-az1",
//				"eastus-az2",
//				"eastus-az3",
//			}
//			if param := cfg.GetObject("zones"); param != nil {
//				zones = param
//			}
//			throughputTier := "tier-1-azure-v3-x86"
//			if param := cfg.Get("throughputTier"); param != "" {
//				throughputTier = param
//			}
//			testCluster, err := redpanda.NewCluster(ctx, "testCluster", &redpanda.ClusterArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				NetworkId:       testNetwork.ID(),
//				CloudProvider:   testNetwork.CloudProvider,
//				Region:          testNetwork.Region,
//				ClusterType:     testNetwork.ClusterType,
//				ConnectionType:  pulumi.String("public"),
//				ThroughputTier:  pulumi.String(throughputTier),
//				Zones:           pulumi.Any(zones),
//				AllowDeletion:   pulumi.Bool(true),
//				Tags: pulumi.StringMap{
//					"key": pulumi.String("value"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			resourceGroupName := "testname"
//			if param := cfg.Get("resourceGroupName"); param != "" {
//				resourceGroupName = param
//			}
//			networkName := "testname"
//			if param := cfg.Get("networkName"); param != "" {
//				networkName = param
//			}
//			clusterName := "testname"
//			if param := cfg.Get("clusterName"); param != "" {
//				clusterName = param
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			testTopic, err := redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     testCluster.ClusterApiUrl,
//				AllowDeletion:     pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("TOPIC"),
//				ResourceName:        testTopic.Name,
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("READ"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			userName := "test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## BYOVPC
//
// This accepts a network and other elements created by the end user inside their cloud provider account (currently limited to AWS) and builds a Redpanda Cluster inside it.
//
// There is a module provided for convenience of the end user here that handles the necessary setup. It contains outputs for the inputs the provider requires.
//
// ### Example Usage of a data source BYOC to manage users and ACLs
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			clusterId := ""
//			if param := cfg.Get("clusterId"); param != "" {
//				clusterId = param
//			}
//			testCluster, err := redpanda.LookupCluster(ctx, &redpanda.LookupClusterArgs{
//				Id: clusterId,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			topicConfig := map[string]interface{}{
//				"cleanup.policy":   "compact",
//				"flush.ms":         100,
//				"compression.type": "snappy",
//			}
//			if param := cfg.GetObject("topicConfig"); param != nil {
//				topicConfig = param
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			_, err = redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     pulumi.String(testCluster.ClusterApiUrl),
//				AllowDeletion:     pulumi.Bool(true),
//				Configuration:     pulumi.Any(topicConfig),
//			})
//			if err != nil {
//				return err
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: pulumi.String(testCluster.ClusterApiUrl),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("CLUSTER"),
//				ResourceName:        pulumi.String("kafka-cluster"),
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("ALTER"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  pulumi.String(testCluster.ClusterApiUrl),
//			})
//			if err != nil {
//				return err
//			}
//			userName := "data-test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "data-test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import redpanda:index/cluster:Cluster example clusterId
// ```
type Cluster struct {
	pulumi.CustomResourceState

	// Allows deletion of the cluster. Defaults to false.
	AllowDeletion pulumi.BoolPtrOutput `pulumi:"allowDeletion"`
	// AWS PrivateLink configuration.
	AwsPrivateLink ClusterAwsPrivateLinkPtrOutput `pulumi:"awsPrivateLink"`
	// Azure Private Link configuration.
	AzurePrivateLink ClusterAzurePrivateLinkPtrOutput `pulumi:"azurePrivateLink"`
	// Cloud provider where resources are created.
	CloudProvider pulumi.StringPtrOutput `pulumi:"cloudProvider"`
	// The URL of the cluster API.
	ClusterApiUrl pulumi.StringOutput `pulumi:"clusterApiUrl"`
	// Cluster type. Type is immutable and can only be set on cluster creation.
	ClusterType pulumi.StringOutput `pulumi:"clusterType"`
	// Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
	ConnectionType pulumi.StringOutput `pulumi:"connectionType"`
	// Timestamp when the cluster was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Customer managed resources configuration for the cluster.
	CustomerManagedResources ClusterCustomerManagedResourcesPtrOutput `pulumi:"customerManagedResources"`
	// If true, GCP global access is enabled.
	GcpGlobalAccessEnabled pulumi.BoolPtrOutput `pulumi:"gcpGlobalAccessEnabled"`
	// GCP Private Service Connect configuration.
	GcpPrivateServiceConnect ClusterGcpPrivateServiceConnectPtrOutput `pulumi:"gcpPrivateServiceConnect"`
	// HTTP Proxy properties.
	HttpProxy ClusterHttpProxyOutput `pulumi:"httpProxy"`
	// Cluster's Kafka API properties.
	KafkaApi ClusterKafkaApiOutput `pulumi:"kafkaApi"`
	// Kafka Connect configuration.
	KafkaConnect ClusterKafkaConnectOutput `pulumi:"kafkaConnect"`
	// Maintenance window configuration for the cluster.
	MaintenanceWindowConfig ClusterMaintenanceWindowConfigOutput `pulumi:"maintenanceWindowConfig"`
	// Unique name of the cluster.
	Name pulumi.StringOutput `pulumi:"name"`
	// Network ID where cluster is placed.
	NetworkId pulumi.StringOutput `pulumi:"networkId"`
	// Prometheus metrics endpoint properties.
	Prometheus ClusterPrometheusOutput `pulumi:"prometheus"`
	// IDs of clusters that can create read-only topics from this cluster.
	ReadReplicaClusterIds pulumi.StringArrayOutput `pulumi:"readReplicaClusterIds"`
	// Redpanda Console properties.
	RedpandaConsole ClusterRedpandaConsoleOutput `pulumi:"redpandaConsole"`
	// Current Redpanda version of the cluster.
	RedpandaVersion pulumi.StringPtrOutput `pulumi:"redpandaVersion"`
	// Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
	Region pulumi.StringPtrOutput `pulumi:"region"`
	// Resource group ID of the cluster.
	ResourceGroupId pulumi.StringOutput `pulumi:"resourceGroupId"`
	// Schema Registry properties.
	SchemaRegistry ClusterSchemaRegistryOutput `pulumi:"schemaRegistry"`
	// Current state of the cluster.
	State pulumi.StringOutput `pulumi:"state"`
	// Detailed state description when cluster is in a non-ready state.
	StateDescription ClusterStateDescriptionOutput `pulumi:"stateDescription"`
	// Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Throughput tier of the cluster.
	ThroughputTier pulumi.StringOutput `pulumi:"throughputTier"`
	// Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
	Zones pulumi.StringArrayOutput `pulumi:"zones"`
}

// NewCluster registers a new resource with the given unique name, arguments, and options.
func NewCluster(ctx *pulumi.Context,
	name string, args *ClusterArgs, opts ...pulumi.ResourceOption) (*Cluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterType == nil {
		return nil, errors.New("invalid value for required argument 'ClusterType'")
	}
	if args.ConnectionType == nil {
		return nil, errors.New("invalid value for required argument 'ConnectionType'")
	}
	if args.NetworkId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkId'")
	}
	if args.ResourceGroupId == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupId'")
	}
	if args.ThroughputTier == nil {
		return nil, errors.New("invalid value for required argument 'ThroughputTier'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Cluster
	err := ctx.RegisterResource("redpanda:index/cluster:Cluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCluster gets an existing Cluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterState, opts ...pulumi.ResourceOption) (*Cluster, error) {
	var resource Cluster
	err := ctx.ReadResource("redpanda:index/cluster:Cluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Cluster resources.
type clusterState struct {
	// Allows deletion of the cluster. Defaults to false.
	AllowDeletion *bool `pulumi:"allowDeletion"`
	// AWS PrivateLink configuration.
	AwsPrivateLink *ClusterAwsPrivateLink `pulumi:"awsPrivateLink"`
	// Azure Private Link configuration.
	AzurePrivateLink *ClusterAzurePrivateLink `pulumi:"azurePrivateLink"`
	// Cloud provider where resources are created.
	CloudProvider *string `pulumi:"cloudProvider"`
	// The URL of the cluster API.
	ClusterApiUrl *string `pulumi:"clusterApiUrl"`
	// Cluster type. Type is immutable and can only be set on cluster creation.
	ClusterType *string `pulumi:"clusterType"`
	// Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
	ConnectionType *string `pulumi:"connectionType"`
	// Timestamp when the cluster was created.
	CreatedAt *string `pulumi:"createdAt"`
	// Customer managed resources configuration for the cluster.
	CustomerManagedResources *ClusterCustomerManagedResources `pulumi:"customerManagedResources"`
	// If true, GCP global access is enabled.
	GcpGlobalAccessEnabled *bool `pulumi:"gcpGlobalAccessEnabled"`
	// GCP Private Service Connect configuration.
	GcpPrivateServiceConnect *ClusterGcpPrivateServiceConnect `pulumi:"gcpPrivateServiceConnect"`
	// HTTP Proxy properties.
	HttpProxy *ClusterHttpProxy `pulumi:"httpProxy"`
	// Cluster's Kafka API properties.
	KafkaApi *ClusterKafkaApi `pulumi:"kafkaApi"`
	// Kafka Connect configuration.
	KafkaConnect *ClusterKafkaConnect `pulumi:"kafkaConnect"`
	// Maintenance window configuration for the cluster.
	MaintenanceWindowConfig *ClusterMaintenanceWindowConfig `pulumi:"maintenanceWindowConfig"`
	// Unique name of the cluster.
	Name *string `pulumi:"name"`
	// Network ID where cluster is placed.
	NetworkId *string `pulumi:"networkId"`
	// Prometheus metrics endpoint properties.
	Prometheus *ClusterPrometheus `pulumi:"prometheus"`
	// IDs of clusters that can create read-only topics from this cluster.
	ReadReplicaClusterIds []string `pulumi:"readReplicaClusterIds"`
	// Redpanda Console properties.
	RedpandaConsole *ClusterRedpandaConsole `pulumi:"redpandaConsole"`
	// Current Redpanda version of the cluster.
	RedpandaVersion *string `pulumi:"redpandaVersion"`
	// Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
	Region *string `pulumi:"region"`
	// Resource group ID of the cluster.
	ResourceGroupId *string `pulumi:"resourceGroupId"`
	// Schema Registry properties.
	SchemaRegistry *ClusterSchemaRegistry `pulumi:"schemaRegistry"`
	// Current state of the cluster.
	State *string `pulumi:"state"`
	// Detailed state description when cluster is in a non-ready state.
	StateDescription *ClusterStateDescription `pulumi:"stateDescription"`
	// Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
	Tags map[string]string `pulumi:"tags"`
	// Throughput tier of the cluster.
	ThroughputTier *string `pulumi:"throughputTier"`
	// Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
	Zones []string `pulumi:"zones"`
}

type ClusterState struct {
	// Allows deletion of the cluster. Defaults to false.
	AllowDeletion pulumi.BoolPtrInput
	// AWS PrivateLink configuration.
	AwsPrivateLink ClusterAwsPrivateLinkPtrInput
	// Azure Private Link configuration.
	AzurePrivateLink ClusterAzurePrivateLinkPtrInput
	// Cloud provider where resources are created.
	CloudProvider pulumi.StringPtrInput
	// The URL of the cluster API.
	ClusterApiUrl pulumi.StringPtrInput
	// Cluster type. Type is immutable and can only be set on cluster creation.
	ClusterType pulumi.StringPtrInput
	// Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
	ConnectionType pulumi.StringPtrInput
	// Timestamp when the cluster was created.
	CreatedAt pulumi.StringPtrInput
	// Customer managed resources configuration for the cluster.
	CustomerManagedResources ClusterCustomerManagedResourcesPtrInput
	// If true, GCP global access is enabled.
	GcpGlobalAccessEnabled pulumi.BoolPtrInput
	// GCP Private Service Connect configuration.
	GcpPrivateServiceConnect ClusterGcpPrivateServiceConnectPtrInput
	// HTTP Proxy properties.
	HttpProxy ClusterHttpProxyPtrInput
	// Cluster's Kafka API properties.
	KafkaApi ClusterKafkaApiPtrInput
	// Kafka Connect configuration.
	KafkaConnect ClusterKafkaConnectPtrInput
	// Maintenance window configuration for the cluster.
	MaintenanceWindowConfig ClusterMaintenanceWindowConfigPtrInput
	// Unique name of the cluster.
	Name pulumi.StringPtrInput
	// Network ID where cluster is placed.
	NetworkId pulumi.StringPtrInput
	// Prometheus metrics endpoint properties.
	Prometheus ClusterPrometheusPtrInput
	// IDs of clusters that can create read-only topics from this cluster.
	ReadReplicaClusterIds pulumi.StringArrayInput
	// Redpanda Console properties.
	RedpandaConsole ClusterRedpandaConsolePtrInput
	// Current Redpanda version of the cluster.
	RedpandaVersion pulumi.StringPtrInput
	// Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
	Region pulumi.StringPtrInput
	// Resource group ID of the cluster.
	ResourceGroupId pulumi.StringPtrInput
	// Schema Registry properties.
	SchemaRegistry ClusterSchemaRegistryPtrInput
	// Current state of the cluster.
	State pulumi.StringPtrInput
	// Detailed state description when cluster is in a non-ready state.
	StateDescription ClusterStateDescriptionPtrInput
	// Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
	Tags pulumi.StringMapInput
	// Throughput tier of the cluster.
	ThroughputTier pulumi.StringPtrInput
	// Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
	Zones pulumi.StringArrayInput
}

func (ClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterState)(nil)).Elem()
}

type clusterArgs struct {
	// Allows deletion of the cluster. Defaults to false.
	AllowDeletion *bool `pulumi:"allowDeletion"`
	// AWS PrivateLink configuration.
	AwsPrivateLink *ClusterAwsPrivateLink `pulumi:"awsPrivateLink"`
	// Azure Private Link configuration.
	AzurePrivateLink *ClusterAzurePrivateLink `pulumi:"azurePrivateLink"`
	// Cloud provider where resources are created.
	CloudProvider *string `pulumi:"cloudProvider"`
	// Cluster type. Type is immutable and can only be set on cluster creation.
	ClusterType string `pulumi:"clusterType"`
	// Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
	ConnectionType string `pulumi:"connectionType"`
	// Customer managed resources configuration for the cluster.
	CustomerManagedResources *ClusterCustomerManagedResources `pulumi:"customerManagedResources"`
	// If true, GCP global access is enabled.
	GcpGlobalAccessEnabled *bool `pulumi:"gcpGlobalAccessEnabled"`
	// GCP Private Service Connect configuration.
	GcpPrivateServiceConnect *ClusterGcpPrivateServiceConnect `pulumi:"gcpPrivateServiceConnect"`
	// HTTP Proxy properties.
	HttpProxy *ClusterHttpProxy `pulumi:"httpProxy"`
	// Cluster's Kafka API properties.
	KafkaApi *ClusterKafkaApi `pulumi:"kafkaApi"`
	// Kafka Connect configuration.
	KafkaConnect *ClusterKafkaConnect `pulumi:"kafkaConnect"`
	// Maintenance window configuration for the cluster.
	MaintenanceWindowConfig *ClusterMaintenanceWindowConfig `pulumi:"maintenanceWindowConfig"`
	// Unique name of the cluster.
	Name *string `pulumi:"name"`
	// Network ID where cluster is placed.
	NetworkId string `pulumi:"networkId"`
	// IDs of clusters that can create read-only topics from this cluster.
	ReadReplicaClusterIds []string `pulumi:"readReplicaClusterIds"`
	// Current Redpanda version of the cluster.
	RedpandaVersion *string `pulumi:"redpandaVersion"`
	// Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
	Region *string `pulumi:"region"`
	// Resource group ID of the cluster.
	ResourceGroupId string `pulumi:"resourceGroupId"`
	// Schema Registry properties.
	SchemaRegistry *ClusterSchemaRegistry `pulumi:"schemaRegistry"`
	// Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
	Tags map[string]string `pulumi:"tags"`
	// Throughput tier of the cluster.
	ThroughputTier string `pulumi:"throughputTier"`
	// Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
	Zones []string `pulumi:"zones"`
}

// The set of arguments for constructing a Cluster resource.
type ClusterArgs struct {
	// Allows deletion of the cluster. Defaults to false.
	AllowDeletion pulumi.BoolPtrInput
	// AWS PrivateLink configuration.
	AwsPrivateLink ClusterAwsPrivateLinkPtrInput
	// Azure Private Link configuration.
	AzurePrivateLink ClusterAzurePrivateLinkPtrInput
	// Cloud provider where resources are created.
	CloudProvider pulumi.StringPtrInput
	// Cluster type. Type is immutable and can only be set on cluster creation.
	ClusterType pulumi.StringInput
	// Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
	ConnectionType pulumi.StringInput
	// Customer managed resources configuration for the cluster.
	CustomerManagedResources ClusterCustomerManagedResourcesPtrInput
	// If true, GCP global access is enabled.
	GcpGlobalAccessEnabled pulumi.BoolPtrInput
	// GCP Private Service Connect configuration.
	GcpPrivateServiceConnect ClusterGcpPrivateServiceConnectPtrInput
	// HTTP Proxy properties.
	HttpProxy ClusterHttpProxyPtrInput
	// Cluster's Kafka API properties.
	KafkaApi ClusterKafkaApiPtrInput
	// Kafka Connect configuration.
	KafkaConnect ClusterKafkaConnectPtrInput
	// Maintenance window configuration for the cluster.
	MaintenanceWindowConfig ClusterMaintenanceWindowConfigPtrInput
	// Unique name of the cluster.
	Name pulumi.StringPtrInput
	// Network ID where cluster is placed.
	NetworkId pulumi.StringInput
	// IDs of clusters that can create read-only topics from this cluster.
	ReadReplicaClusterIds pulumi.StringArrayInput
	// Current Redpanda version of the cluster.
	RedpandaVersion pulumi.StringPtrInput
	// Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
	Region pulumi.StringPtrInput
	// Resource group ID of the cluster.
	ResourceGroupId pulumi.StringInput
	// Schema Registry properties.
	SchemaRegistry ClusterSchemaRegistryPtrInput
	// Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
	Tags pulumi.StringMapInput
	// Throughput tier of the cluster.
	ThroughputTier pulumi.StringInput
	// Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
	Zones pulumi.StringArrayInput
}

func (ClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterArgs)(nil)).Elem()
}

type ClusterInput interface {
	pulumi.Input

	ToClusterOutput() ClusterOutput
	ToClusterOutputWithContext(ctx context.Context) ClusterOutput
}

func (*Cluster) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil)).Elem()
}

func (i *Cluster) ToClusterOutput() ClusterOutput {
	return i.ToClusterOutputWithContext(context.Background())
}

func (i *Cluster) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterOutput)
}

// ClusterArrayInput is an input type that accepts ClusterArray and ClusterArrayOutput values.
// You can construct a concrete instance of `ClusterArrayInput` via:
//
//	ClusterArray{ ClusterArgs{...} }
type ClusterArrayInput interface {
	pulumi.Input

	ToClusterArrayOutput() ClusterArrayOutput
	ToClusterArrayOutputWithContext(context.Context) ClusterArrayOutput
}

type ClusterArray []ClusterInput

func (ClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cluster)(nil)).Elem()
}

func (i ClusterArray) ToClusterArrayOutput() ClusterArrayOutput {
	return i.ToClusterArrayOutputWithContext(context.Background())
}

func (i ClusterArray) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterArrayOutput)
}

// ClusterMapInput is an input type that accepts ClusterMap and ClusterMapOutput values.
// You can construct a concrete instance of `ClusterMapInput` via:
//
//	ClusterMap{ "key": ClusterArgs{...} }
type ClusterMapInput interface {
	pulumi.Input

	ToClusterMapOutput() ClusterMapOutput
	ToClusterMapOutputWithContext(context.Context) ClusterMapOutput
}

type ClusterMap map[string]ClusterInput

func (ClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cluster)(nil)).Elem()
}

func (i ClusterMap) ToClusterMapOutput() ClusterMapOutput {
	return i.ToClusterMapOutputWithContext(context.Background())
}

func (i ClusterMap) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMapOutput)
}

type ClusterOutput struct{ *pulumi.OutputState }

func (ClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil)).Elem()
}

func (o ClusterOutput) ToClusterOutput() ClusterOutput {
	return o
}

func (o ClusterOutput) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return o
}

// Allows deletion of the cluster. Defaults to false.
func (o ClusterOutput) AllowDeletion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.BoolPtrOutput { return v.AllowDeletion }).(pulumi.BoolPtrOutput)
}

// AWS PrivateLink configuration.
func (o ClusterOutput) AwsPrivateLink() ClusterAwsPrivateLinkPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterAwsPrivateLinkPtrOutput { return v.AwsPrivateLink }).(ClusterAwsPrivateLinkPtrOutput)
}

// Azure Private Link configuration.
func (o ClusterOutput) AzurePrivateLink() ClusterAzurePrivateLinkPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterAzurePrivateLinkPtrOutput { return v.AzurePrivateLink }).(ClusterAzurePrivateLinkPtrOutput)
}

// Cloud provider where resources are created.
func (o ClusterOutput) CloudProvider() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.CloudProvider }).(pulumi.StringPtrOutput)
}

// The URL of the cluster API.
func (o ClusterOutput) ClusterApiUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ClusterApiUrl }).(pulumi.StringOutput)
}

// Cluster type. Type is immutable and can only be set on cluster creation.
func (o ClusterOutput) ClusterType() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ClusterType }).(pulumi.StringOutput)
}

// Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
func (o ClusterOutput) ConnectionType() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ConnectionType }).(pulumi.StringOutput)
}

// Timestamp when the cluster was created.
func (o ClusterOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Customer managed resources configuration for the cluster.
func (o ClusterOutput) CustomerManagedResources() ClusterCustomerManagedResourcesPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterCustomerManagedResourcesPtrOutput { return v.CustomerManagedResources }).(ClusterCustomerManagedResourcesPtrOutput)
}

// If true, GCP global access is enabled.
func (o ClusterOutput) GcpGlobalAccessEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.BoolPtrOutput { return v.GcpGlobalAccessEnabled }).(pulumi.BoolPtrOutput)
}

// GCP Private Service Connect configuration.
func (o ClusterOutput) GcpPrivateServiceConnect() ClusterGcpPrivateServiceConnectPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterGcpPrivateServiceConnectPtrOutput { return v.GcpPrivateServiceConnect }).(ClusterGcpPrivateServiceConnectPtrOutput)
}

// HTTP Proxy properties.
func (o ClusterOutput) HttpProxy() ClusterHttpProxyOutput {
	return o.ApplyT(func(v *Cluster) ClusterHttpProxyOutput { return v.HttpProxy }).(ClusterHttpProxyOutput)
}

// Cluster's Kafka API properties.
func (o ClusterOutput) KafkaApi() ClusterKafkaApiOutput {
	return o.ApplyT(func(v *Cluster) ClusterKafkaApiOutput { return v.KafkaApi }).(ClusterKafkaApiOutput)
}

// Kafka Connect configuration.
func (o ClusterOutput) KafkaConnect() ClusterKafkaConnectOutput {
	return o.ApplyT(func(v *Cluster) ClusterKafkaConnectOutput { return v.KafkaConnect }).(ClusterKafkaConnectOutput)
}

// Maintenance window configuration for the cluster.
func (o ClusterOutput) MaintenanceWindowConfig() ClusterMaintenanceWindowConfigOutput {
	return o.ApplyT(func(v *Cluster) ClusterMaintenanceWindowConfigOutput { return v.MaintenanceWindowConfig }).(ClusterMaintenanceWindowConfigOutput)
}

// Unique name of the cluster.
func (o ClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Network ID where cluster is placed.
func (o ClusterOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.NetworkId }).(pulumi.StringOutput)
}

// Prometheus metrics endpoint properties.
func (o ClusterOutput) Prometheus() ClusterPrometheusOutput {
	return o.ApplyT(func(v *Cluster) ClusterPrometheusOutput { return v.Prometheus }).(ClusterPrometheusOutput)
}

// IDs of clusters that can create read-only topics from this cluster.
func (o ClusterOutput) ReadReplicaClusterIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringArrayOutput { return v.ReadReplicaClusterIds }).(pulumi.StringArrayOutput)
}

// Redpanda Console properties.
func (o ClusterOutput) RedpandaConsole() ClusterRedpandaConsoleOutput {
	return o.ApplyT(func(v *Cluster) ClusterRedpandaConsoleOutput { return v.RedpandaConsole }).(ClusterRedpandaConsoleOutput)
}

// Current Redpanda version of the cluster.
func (o ClusterOutput) RedpandaVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.RedpandaVersion }).(pulumi.StringPtrOutput)
}

// Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
func (o ClusterOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.Region }).(pulumi.StringPtrOutput)
}

// Resource group ID of the cluster.
func (o ClusterOutput) ResourceGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ResourceGroupId }).(pulumi.StringOutput)
}

// Schema Registry properties.
func (o ClusterOutput) SchemaRegistry() ClusterSchemaRegistryOutput {
	return o.ApplyT(func(v *Cluster) ClusterSchemaRegistryOutput { return v.SchemaRegistry }).(ClusterSchemaRegistryOutput)
}

// Current state of the cluster.
func (o ClusterOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Detailed state description when cluster is in a non-ready state.
func (o ClusterOutput) StateDescription() ClusterStateDescriptionOutput {
	return o.ApplyT(func(v *Cluster) ClusterStateDescriptionOutput { return v.StateDescription }).(ClusterStateDescriptionOutput)
}

// Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
func (o ClusterOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Throughput tier of the cluster.
func (o ClusterOutput) ThroughputTier() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ThroughputTier }).(pulumi.StringOutput)
}

// Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
func (o ClusterOutput) Zones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringArrayOutput { return v.Zones }).(pulumi.StringArrayOutput)
}

type ClusterArrayOutput struct{ *pulumi.OutputState }

func (ClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cluster)(nil)).Elem()
}

func (o ClusterArrayOutput) ToClusterArrayOutput() ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) Index(i pulumi.IntInput) ClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Cluster {
		return vs[0].([]*Cluster)[vs[1].(int)]
	}).(ClusterOutput)
}

type ClusterMapOutput struct{ *pulumi.OutputState }

func (ClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cluster)(nil)).Elem()
}

func (o ClusterMapOutput) ToClusterMapOutput() ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) MapIndex(k pulumi.StringInput) ClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Cluster {
		return vs[0].(map[string]*Cluster)[vs[1].(string)]
	}).(ClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterInput)(nil)).Elem(), &Cluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterArrayInput)(nil)).Elem(), ClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterMapInput)(nil)).Elem(), ClusterMap{})
	pulumi.RegisterOutputType(ClusterOutput{})
	pulumi.RegisterOutputType(ClusterArrayOutput{})
	pulumi.RegisterOutputType(ClusterMapOutput{})
}
