// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package redpanda

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda/internal"
)

// Topic represents a Kafka topic configuration
//
// # Creates a topic in a Redpanda Cluster
//
// ## Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/pulumiverse/pulumi-redpanda/sdk/go/redpanda"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := redpanda.NewResourceGroup(ctx, "testResourceGroup", nil)
//			if err != nil {
//				return err
//			}
//			cfg := config.New(ctx, "")
//			region := "us-east-2"
//			if param := cfg.Get("region"); param != "" {
//				region = param
//			}
//			cloudProvider := "aws"
//			if param := cfg.Get("cloudProvider"); param != "" {
//				cloudProvider = param
//			}
//			testNetwork, err := redpanda.NewNetwork(ctx, "testNetwork", &redpanda.NetworkArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				CidrBlock:       pulumi.String("10.0.0.0/20"),
//			})
//			if err != nil {
//				return err
//			}
//			zones := []string{
//				"use2-az1",
//				"use2-az2",
//				"use2-az3",
//			}
//			if param := cfg.GetObject("zones"); param != nil {
//				zones = param
//			}
//			throughputTier := "tier-1-aws-v2-arm"
//			if param := cfg.Get("throughputTier"); param != "" {
//				throughputTier = param
//			}
//			testCluster, err := redpanda.NewCluster(ctx, "testCluster", &redpanda.ClusterArgs{
//				ResourceGroupId: testResourceGroup.ID(),
//				NetworkId:       testNetwork.ID(),
//				CloudProvider:   pulumi.String(cloudProvider),
//				Region:          pulumi.String(region),
//				ClusterType:     pulumi.String("dedicated"),
//				ConnectionType:  pulumi.String("public"),
//				ThroughputTier:  pulumi.String(throughputTier),
//				Zones:           pulumi.Any(zones),
//				AllowDeletion:   pulumi.Bool(true),
//				Tags: pulumi.StringMap{
//					"key": pulumi.String("value"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			resourceGroupName := "testname"
//			if param := cfg.Get("resourceGroupName"); param != "" {
//				resourceGroupName = param
//			}
//			networkName := "testname"
//			if param := cfg.Get("networkName"); param != "" {
//				networkName = param
//			}
//			clusterName := "testname"
//			if param := cfg.Get("clusterName"); param != "" {
//				clusterName = param
//			}
//			userPw := "password"
//			if param := cfg.Get("userPw"); param != "" {
//				userPw = param
//			}
//			mechanism := "scram-sha-256"
//			if param := cfg.Get("mechanism"); param != "" {
//				mechanism = param
//			}
//			testUser, err := redpanda.NewUser(ctx, "testUser", &redpanda.UserArgs{
//				Password:      pulumi.String(userPw),
//				Mechanism:     pulumi.String(mechanism),
//				ClusterApiUrl: testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			partitionCount := float64(3)
//			if param := cfg.GetFloat64("partitionCount"); param != 0 {
//				partitionCount = param
//			}
//			replicationFactor := float64(3)
//			if param := cfg.GetFloat64("replicationFactor"); param != 0 {
//				replicationFactor = param
//			}
//			testTopic, err := redpanda.NewTopic(ctx, "testTopic", &redpanda.TopicArgs{
//				PartitionCount:    pulumi.Float64(partitionCount),
//				ReplicationFactor: pulumi.Float64(replicationFactor),
//				ClusterApiUrl:     testCluster.ClusterApiUrl,
//				AllowDeletion:     pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = redpanda.NewAcl(ctx, "testAcl", &redpanda.AclArgs{
//				ResourceType:        pulumi.String("TOPIC"),
//				ResourceName:        testTopic.Name,
//				ResourcePatternType: pulumi.String("LITERAL"),
//				Principal: testUser.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("User:%v", name), nil
//				}).(pulumi.StringOutput),
//				Host:           pulumi.String("*"),
//				Operation:      pulumi.String("READ"),
//				PermissionType: pulumi.String("ALLOW"),
//				ClusterApiUrl:  testCluster.ClusterApiUrl,
//			})
//			if err != nil {
//				return err
//			}
//			userName := "test-username"
//			if param := cfg.Get("userName"); param != "" {
//				userName = param
//			}
//			topicName := "test-topic"
//			if param := cfg.Get("topicName"); param != "" {
//				topicName = param
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Limitations
//
// We are not currently able to support topic creation in self hosted clusters. This is an area of active development so expect that to change soon.
//
// ## Import
//
// ```sh
// $ pulumi import redpanda:index/topic:Topic example topicName,clusterId
// ```
//
// Where clusterId is the ID of the cluster in Redpanda Cloud
type Topic struct {
	pulumi.CustomResourceState

	// Indicates whether the topic can be deleted.
	AllowDeletion pulumi.BoolPtrOutput `pulumi:"allowDeletion"`
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	ClusterApiUrl pulumi.StringOutput `pulumi:"clusterApiUrl"`
	// A map of string key/value pairs of topic configurations.
	Configuration pulumi.StringMapOutput `pulumi:"configuration"`
	// The name of the topic.
	Name pulumi.StringOutput `pulumi:"name"`
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss. Decreases will destroy and recreate the topic if allowDeletion is set to true (defaults to false).
	PartitionCount pulumi.Float64Output `pulumi:"partitionCount"`
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	ReplicationFactor pulumi.Float64Output `pulumi:"replicationFactor"`
}

// NewTopic registers a new resource with the given unique name, arguments, and options.
func NewTopic(ctx *pulumi.Context,
	name string, args *TopicArgs, opts ...pulumi.ResourceOption) (*Topic, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterApiUrl == nil {
		return nil, errors.New("invalid value for required argument 'ClusterApiUrl'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Topic
	err := ctx.RegisterResource("redpanda:index/topic:Topic", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTopic gets an existing Topic resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTopic(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TopicState, opts ...pulumi.ResourceOption) (*Topic, error) {
	var resource Topic
	err := ctx.ReadResource("redpanda:index/topic:Topic", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Topic resources.
type topicState struct {
	// Indicates whether the topic can be deleted.
	AllowDeletion *bool `pulumi:"allowDeletion"`
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	ClusterApiUrl *string `pulumi:"clusterApiUrl"`
	// A map of string key/value pairs of topic configurations.
	Configuration map[string]string `pulumi:"configuration"`
	// The name of the topic.
	Name *string `pulumi:"name"`
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss. Decreases will destroy and recreate the topic if allowDeletion is set to true (defaults to false).
	PartitionCount *float64 `pulumi:"partitionCount"`
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	ReplicationFactor *float64 `pulumi:"replicationFactor"`
}

type TopicState struct {
	// Indicates whether the topic can be deleted.
	AllowDeletion pulumi.BoolPtrInput
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	ClusterApiUrl pulumi.StringPtrInput
	// A map of string key/value pairs of topic configurations.
	Configuration pulumi.StringMapInput
	// The name of the topic.
	Name pulumi.StringPtrInput
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss. Decreases will destroy and recreate the topic if allowDeletion is set to true (defaults to false).
	PartitionCount pulumi.Float64PtrInput
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	ReplicationFactor pulumi.Float64PtrInput
}

func (TopicState) ElementType() reflect.Type {
	return reflect.TypeOf((*topicState)(nil)).Elem()
}

type topicArgs struct {
	// Indicates whether the topic can be deleted.
	AllowDeletion *bool `pulumi:"allowDeletion"`
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	ClusterApiUrl string `pulumi:"clusterApiUrl"`
	// A map of string key/value pairs of topic configurations.
	Configuration map[string]string `pulumi:"configuration"`
	// The name of the topic.
	Name *string `pulumi:"name"`
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss. Decreases will destroy and recreate the topic if allowDeletion is set to true (defaults to false).
	PartitionCount *float64 `pulumi:"partitionCount"`
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	ReplicationFactor *float64 `pulumi:"replicationFactor"`
}

// The set of arguments for constructing a Topic resource.
type TopicArgs struct {
	// Indicates whether the topic can be deleted.
	AllowDeletion pulumi.BoolPtrInput
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	ClusterApiUrl pulumi.StringInput
	// A map of string key/value pairs of topic configurations.
	Configuration pulumi.StringMapInput
	// The name of the topic.
	Name pulumi.StringPtrInput
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss. Decreases will destroy and recreate the topic if allowDeletion is set to true (defaults to false).
	PartitionCount pulumi.Float64PtrInput
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	ReplicationFactor pulumi.Float64PtrInput
}

func (TopicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*topicArgs)(nil)).Elem()
}

type TopicInput interface {
	pulumi.Input

	ToTopicOutput() TopicOutput
	ToTopicOutputWithContext(ctx context.Context) TopicOutput
}

func (*Topic) ElementType() reflect.Type {
	return reflect.TypeOf((**Topic)(nil)).Elem()
}

func (i *Topic) ToTopicOutput() TopicOutput {
	return i.ToTopicOutputWithContext(context.Background())
}

func (i *Topic) ToTopicOutputWithContext(ctx context.Context) TopicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicOutput)
}

// TopicArrayInput is an input type that accepts TopicArray and TopicArrayOutput values.
// You can construct a concrete instance of `TopicArrayInput` via:
//
//	TopicArray{ TopicArgs{...} }
type TopicArrayInput interface {
	pulumi.Input

	ToTopicArrayOutput() TopicArrayOutput
	ToTopicArrayOutputWithContext(context.Context) TopicArrayOutput
}

type TopicArray []TopicInput

func (TopicArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Topic)(nil)).Elem()
}

func (i TopicArray) ToTopicArrayOutput() TopicArrayOutput {
	return i.ToTopicArrayOutputWithContext(context.Background())
}

func (i TopicArray) ToTopicArrayOutputWithContext(ctx context.Context) TopicArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicArrayOutput)
}

// TopicMapInput is an input type that accepts TopicMap and TopicMapOutput values.
// You can construct a concrete instance of `TopicMapInput` via:
//
//	TopicMap{ "key": TopicArgs{...} }
type TopicMapInput interface {
	pulumi.Input

	ToTopicMapOutput() TopicMapOutput
	ToTopicMapOutputWithContext(context.Context) TopicMapOutput
}

type TopicMap map[string]TopicInput

func (TopicMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Topic)(nil)).Elem()
}

func (i TopicMap) ToTopicMapOutput() TopicMapOutput {
	return i.ToTopicMapOutputWithContext(context.Background())
}

func (i TopicMap) ToTopicMapOutputWithContext(ctx context.Context) TopicMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicMapOutput)
}

type TopicOutput struct{ *pulumi.OutputState }

func (TopicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Topic)(nil)).Elem()
}

func (o TopicOutput) ToTopicOutput() TopicOutput {
	return o
}

func (o TopicOutput) ToTopicOutputWithContext(ctx context.Context) TopicOutput {
	return o
}

// Indicates whether the topic can be deleted.
func (o TopicOutput) AllowDeletion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Topic) pulumi.BoolPtrOutput { return v.AllowDeletion }).(pulumi.BoolPtrOutput)
}

// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
func (o TopicOutput) ClusterApiUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringOutput { return v.ClusterApiUrl }).(pulumi.StringOutput)
}

// A map of string key/value pairs of topic configurations.
func (o TopicOutput) Configuration() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringMapOutput { return v.Configuration }).(pulumi.StringMapOutput)
}

// The name of the topic.
func (o TopicOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Topic) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss. Decreases will destroy and recreate the topic if allowDeletion is set to true (defaults to false).
func (o TopicOutput) PartitionCount() pulumi.Float64Output {
	return o.ApplyT(func(v *Topic) pulumi.Float64Output { return v.PartitionCount }).(pulumi.Float64Output)
}

// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
func (o TopicOutput) ReplicationFactor() pulumi.Float64Output {
	return o.ApplyT(func(v *Topic) pulumi.Float64Output { return v.ReplicationFactor }).(pulumi.Float64Output)
}

type TopicArrayOutput struct{ *pulumi.OutputState }

func (TopicArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Topic)(nil)).Elem()
}

func (o TopicArrayOutput) ToTopicArrayOutput() TopicArrayOutput {
	return o
}

func (o TopicArrayOutput) ToTopicArrayOutputWithContext(ctx context.Context) TopicArrayOutput {
	return o
}

func (o TopicArrayOutput) Index(i pulumi.IntInput) TopicOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Topic {
		return vs[0].([]*Topic)[vs[1].(int)]
	}).(TopicOutput)
}

type TopicMapOutput struct{ *pulumi.OutputState }

func (TopicMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Topic)(nil)).Elem()
}

func (o TopicMapOutput) ToTopicMapOutput() TopicMapOutput {
	return o
}

func (o TopicMapOutput) ToTopicMapOutputWithContext(ctx context.Context) TopicMapOutput {
	return o
}

func (o TopicMapOutput) MapIndex(k pulumi.StringInput) TopicOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Topic {
		return vs[0].(map[string]*Topic)[vs[1].(string)]
	}).(TopicOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TopicInput)(nil)).Elem(), &Topic{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicArrayInput)(nil)).Elem(), TopicArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicMapInput)(nil)).Elem(), TopicMap{})
	pulumi.RegisterOutputType(TopicOutput{})
	pulumi.RegisterOutputType(TopicArrayOutput{})
	pulumi.RegisterOutputType(TopicMapOutput{})
}
